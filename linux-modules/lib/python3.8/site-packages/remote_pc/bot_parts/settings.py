import os
import json
import asyncio
from aiogram import Bot 
from aiogram.utils.exceptions import Unauthorized, ValidationError
from . import stats 
import sys
import platform

CACHE_PATH = os.path.dirname("./cache/bot/") 
config_json = os.path.join(CACHE_PATH, 'config.json') 

def config_exists():
    if not os.path.exists(CACHE_PATH):
        os.makedirs(CACHE_PATH)
        return False
    if not os.path.exists(config_json):
        return False
    return True
    
def json_config_delete():
    if config_exists():
        os.remove(config_json)

async def register():
    try:
        while True:
            try:
                token=input(f"[1/7] Введите токен бота:\n")
                bot = Bot(token)
                bot_data = await bot.get_me()
                config = {}
                config["bot_options"] = {}
                config["bot_options"]["token"] = token
                config["bot_options"]["username"] = bot_data["username"]
                await bot.close()
                break
            except (Unauthorized, ValidationError):
                print(f"Ошибка: неверный токен. Попробуйте заново.")
                continue
        config["script_options"] = {}
        while True:
            logs = input(f"[2/7] Сохранять логи? [Y/n] Они помогают узнать об ошибках при работе бота.\n")
            if logs in ["Y", "y"]:
                config["script_options"]["log_available"] = True
                break
            elif logs in ["N", "n"]:
                config["script_options"]["log_available"] = False
                break
        while True:
            sys_freq = input(f"[3/7] Укажите частоту обновления данных о системе в минутах. [1-60]\nВведите 0, чтобы отключить автообновление данных.\n")
            if sys_freq.isdigit():
                if int(sys_freq) <= 60 and int(sys_freq) >= 0:
                    config["script_options"]["sys_autoupdate"] = sys_freq
                    break
        while True:
            sys_privacy = input(f"[4/7] Укажите доступность данных о системе.\np - Информация приватна\na - Информация публична\n")
            if sys_privacy in ["P", "p"]:
                config["script_options"]["systeminfo_public"] = False
                break
            elif sys_privacy in ["A", "a"]:
                config["script_options"]["systeminfo_public"] = True
                break
        while True:
            net_freq = input(f"[5/7] Укажите частоту обновления данных о сети в минутах. [5-60]\nВведите 0, чтобы отключить автообновление данных.\n")
            if net_freq.isdigit():
                if (int(net_freq) <= 60 and int(net_freq) >= 5) or int(net_freq) == 0:
                    config["script_options"]["net_autoupdate"] = net_freq
                    break
        while True:
            net_privacy = input(f"[6/7] Укажите доступность данных о сети.\np - Информация приватна\na - Информация публична\n")
            if net_privacy in ["P", "p"]:
                config["script_options"]["netinfo_public"] = False
                break
            elif net_privacy in ["A", "a"]:
                config["script_options"]["netinfo_public"] = True
                break
        config["machine_options"] = {}
        config["machine_options"]["progs"] = {}
        config["machine_options"]["progs"]["Windows"] = {}
        config["machine_options"]["progs"]["Linux"] = {} 
        while True:
            user = input(f"[7/7] Хорошо. Введите Ваш ID в Telegram, чтобы завершить настройку бота.\n")
            if user.isdigit(): 
                config["permissions"] = {}
                config["permissions"]["sys_menu"] = {}
                config["permissions"]["sys_menu"]["upd"] = [str(user)]
                config["permissions"]["net_menu"] = {}
                config["permissions"]["net_menu"]["upd"] = [str(user)] 
                config["permissions"]["progs_menu"] = {}
                config["permissions"]["progs_menu"] = [str(user)] 
                config["permissions"]["screen_menu"] = {}
                config["permissions"]["screen_menu"] = [str(user)] 
                config["permissions"]["note_menu"] = {} 
                config["permissions"]["note_menu"] = [str(user)] 
                config["permissions"]["opts"] = {}
                config["permissions"]["opts"] = [str(user)] 
                config["permissions"]["machine_opts"] = {}
                config["permissions"]["machine_opts"] = [str(user)] 
                config["permissions"]["notify"] = [str(user)]
                config["permissions"]["bot_opts"] = {}
                config["permissions"]["bot_opts"] = [str(user)]     
                config["permissions"]["access_opts"] = {}
                config["permissions"]["access_opts"] = [str(user)]
                break 
        with open (config_json, 'w') as config_file:
            json.dump(config, config_file, sort_keys=True, indent=4)
            print("Настройка завершена!")
    except KeyboardInterrupt:
        print("Вы отменили настройку бота...")
        sys.exit()

def json_config_parse():
    if not config_exists():
        try:
            loop = asyncio.get_running_loop()
        except RuntimeError: 
            loop = None
        if not (loop and loop.is_running()):
            asyncio.run(register())
        else:
            print("Бот не может работать без конфигурационного файла!\nПерезапустите бота!")
            sys.exit()
    with open (config_json, 'r') as config_data:
        config = json.load(config_data)
    return config 

def get_bot_token(): 
    config = json_config_parse()
    bot_token = config["bot_options"]["token"]
    return bot_token 

def get_bot_username():  
    config = json_config_parse()
    username = config["bot_options"]["username"] 
    return username

async def set_prog_id():
    config = json_config_parse()
    for i, name in enumerate(config["machine_options"]["progs"][str(platform.uname()[0])]):
        config["machine_options"]["progs"][str(platform.uname()[0])][name]["id"] = str(i)
        with open (config_json, 'w') as config_file: 
            json.dump(config, config_file, sort_keys=True, indent=4)
        
async def progs_add(path):
    config = json_config_parse()
    if os.path.exists(path):
        if os.path.isdir(path):
            name = os.path.split(os.path.dirname(path))[-1]
        elif os.path.isfile(path):
            name = os.path.split(path)[-1]
        config["machine_options"]["progs"][str(platform.uname()[0])][str(name)] = {}
        config["machine_options"]["progs"][str(platform.uname()[0])][str(name)]["path"] = str(path) 
        with open (config_json, 'w') as config_file: 
            json.dump(config, config_file, sort_keys=True, indent=4)
        await stats.log(f"Программа {name} добавлена в меню бота.")
        await set_prog_id()
        return True
    else:
        return False

async def progs_remove(i): 
    config = json_config_parse()
    for name in config["machine_options"]["progs"][str(platform.uname()[0])]:
        if config["machine_options"]["progs"][str(platform.uname()[0])][str(name)]["id"] == str(i):
            config["machine_options"]["progs"][str(platform.uname()[0])].pop(str(name))
            with open (config_json, 'w') as config_file: 
                json.dump(config, config_file, sort_keys=True, indent=4)
            await set_prog_id()
            await stats.log(f"Программа {name} удалена из меню бота.")
            break

async def progs_open(i): 
    config = json_config_parse()
    for name in config["machine_options"]["progs"][str(platform.uname()[0])]:
        if config["machine_options"]["progs"][str(platform.uname()[0])][str(name)]["id"] == str(i):
            prog = f'"{(config["machine_options"]["progs"][str(platform.uname()[0])][str(name)]["path"])}"'
            if platform.uname()[0] == "Windows":
                os.startfile(prog)
            elif platform.uname()[0] == "Linux":
                os.system("xdg-open " + prog)

def get_sys_autoupdate_frequency(): 
    config = json_config_parse()
    value = config["script_options"]["sys_autoupdate"]
    return value 

async def set_sys_autoupdate_frequency(text): 
    config = json_config_parse()
    if text.isdigit():
        value = int(text)
        if value >= 0 and value <= 60:
            config["script_options"]["sys_autoupdate"] = str(value)
            with open (config_json, 'w') as config_file: 
                json.dump(config, config_file, sort_keys=True, indent=4)
            return True
        else:
            await stats.log("Частота обновления данных системы: введите ЧИСЛО от 1 до 60! Если хотите отключить автообновление, то введите 0.")
            return False
    else: 
        await stats.log("Частота обновления данных системы введите ЧИСЛО от 1 до 60! Если хотите отключить автообновление, то введите 0.")
        return False

def get_systeminfo_privacy(): 
    config = json_config_parse()
    value = config["script_options"]["systeminfo_public"]
    return value 

async def set_sysinfo_privacy():
    config = json_config_parse()
    if config["script_options"]["systeminfo_public"]:
        config["script_options"]["systeminfo_public"] = False 
        with open (config_json, 'w') as config_file: 
            json.dump(config, config_file, sort_keys=True, indent=4)
    elif not config["script_options"]["systeminfo_public"]: 
        config["script_options"]["systeminfo_public"] = True
        with open (config_json, 'w') as config_file: 
            json.dump(config, config_file, sort_keys=True, indent=4)
    return config["script_options"]["systeminfo_public"]

def get_net_autoupdate_frequency(): 
    config = json_config_parse()
    value = config["script_options"]["net_autoupdate"]
    return value 

async def set_net_autoupdate_frequency(text): 
    config = json_config_parse()
    if text.isdigit():
        value = int(text)
        if (value >= 5 and value <= 60) or value == 0:
            config["script_options"]["net_autoupdate"] = str(value)
            with open (config_json, 'w') as config_file: 
                json.dump(config, config_file, sort_keys=True, indent=4)
            return True
        else:
            await stats.log("Частота обновления данных сети: введите ЧИСЛО от 5 до 60! Если хотите отключить автообновление, то введите 0.")
            return False
    else: 
        await stats.log("Частота обновления данных сети: введите ЧИСЛО от 5 до 60! Если хотите отключить автообновление, то введите 0.")
        return False

def get_netinfo_privacy(): 
    config = json_config_parse()
    value = config["script_options"]["netinfo_public"]
    return value 

async def set_netinfo_privacy():
    config = json_config_parse()
    if config["script_options"]["netinfo_public"]:
        config["script_options"]["netinfo_public"] = False 
        with open (config_json, 'w') as config_file: 
            json.dump(config, config_file, sort_keys=True, indent=4)
    elif not config["script_options"]["netinfo_public"]: 
        config["script_options"]["netinfo_public"] = True
        with open (config_json, 'w') as config_file: 
            json.dump(config, config_file, sort_keys=True, indent=4)
    return config["script_options"]["netinfo_public"]

def get_logs_status():
    config = json_config_parse()
    value = config["script_options"]["log_available"]
    return value 

async def set_logs_status():
    config = json_config_parse()
    if config["script_options"]["log_available"]:
        config["script_options"]["log_available"] = False 
        with open (config_json, 'w') as config_file: 
            json.dump(config, config_file, sort_keys=True, indent=4)
    elif not config["script_options"]["log_available"]: 
        config["script_options"]["log_available"] = True
        with open (config_json, 'w') as config_file: 
            json.dump(config, config_file, sort_keys=True, indent=4) 
    return config["script_options"]["log_available"]

async def is_user(user, menu_type, menu_action=None):
    config = json_config_parse()
    if menu_type == "sys_menu":
        if not config["script_options"]["systeminfo_public"]:
            return True if str(user) in config["permissions"][str(menu_type)]["upd"] else False
        elif config["script_options"]["systeminfo_public"]:
            if menu_action == "upd":
                return True if str(user) in config["permissions"][str(menu_type)]["upd"] else False
            else:
                return True
    elif menu_type == "net_menu":
        if not config["script_options"]["netinfo_public"]:
            return True if str(user) in config["permissions"][str(menu_type)]["upd"] else False
        elif config["script_options"]["netinfo_public"]:
            if menu_action == "upd":
                return True if str(user) in config["permissions"][str(menu_type)]["upd"] else False
            else:
                return True
    else:
        return True if str(user) in config["permissions"][str(menu_type)] else False

async def get_users(menu_type): 
    config = json_config_parse()
    if menu_type in ["sys_menu", "net_menu"]:
        users = '\n'.join(str(member) for member in config["permissions"][str(menu_type)]["upd"])
    else:
        users = '\n'.join(str(member) for member in config["permissions"][str(menu_type)])
    return users

async def change_users(current_user, target_users, menu_type, action=None): 
    config = json_config_parse()
    for user in target_users.split():
        if user.isdigit() and user != str(current_user):
            if menu_type in ["sys_menu", "net_menu"]:
                if action == "add":
                    if str(user) not in config["permissions"][menu_type]["upd"]:
                        config["permissions"][menu_type]["upd"].append(str(user))
                        with open (config_json, 'w') as config_file: 
                            json.dump(config, config_file, sort_keys=True, indent=4)
                        await stats.log(f"{current_user}, Разрешение {menu_type} выдано пользователю {user}!")
                    else:
                        await stats.log(f"{current_user}, Разрешение {menu_type} уже есть у пользователя {user}!")
                        return False
                elif action == "delete":
                    if str(user) in config["permissions"][menu_type]["upd"]:
                        config["permissions"][menu_type]["upd"].remove(str(user))
                        with open (config_json, 'w') as config_file: 
                            json.dump(config, config_file, sort_keys=True, indent=4)
                        await stats.log(f"{current_user}, Разрешение {menu_type} удалено у пользователя {user}!")
                    else:
                        await stats.log(f"{current_user}, У пользователя {user} не было разрешения {menu_type}!")
                        return False
            else:
                if action == "add":
                    if str(user) not in config["permissions"][menu_type]:
                        config["permissions"][menu_type].append(str(user))
                        with open (config_json, 'w') as config_file: 
                            json.dump(config, config_file, sort_keys=True, indent=4)
                        await stats.log(f"{current_user}, Разрешение {menu_type} выдано пользователю {user}!")
                    else:
                        await stats.log(f"{current_user}, Разрешение {menu_type} уже есть у пользователя {user}!")
                        return False
                elif action == "delete":
                    if str(user) in config["permissions"][menu_type]:
                        config["permissions"][menu_type].remove(str(user))
                        with open (config_json, 'w') as config_file: 
                            json.dump(config, config_file, sort_keys=True, indent=4)
                        await stats.log(f"{current_user}, Разрешение {menu_type} удалено у пользователя {user}!")
                    else:
                        await stats.log(f"{current_user}, У пользователя {user} не было разрешения {menu_type}!")
                        return False
        else:
            await stats.log(f"{current_user}, ID пользователя {user} должен содержать только числа! Также ID пользователя не может совпадать с Вашим ID!")
            return False
    return True
